多态是面向对象编程的三大特征之一。

多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行十七实际类型的方法，例如：

```java
Person p = new Student();
p.run();	//无法确定运行时究竟调用哪个run()方法
```

有同学会问，上面的代码一看就明白，肯定调用的是Student的run()方法啊。

但是，假设我们编写这样一个方法：

```java
public void runTwice(Person p) {
    p.run();
    p.run();
}
```

它传入的参数类型是Person，我们无法知道传入的参数实际类型究竟是还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法

所以，多态的特性就是，运行期才能动态决定调用的子类犯法。对某个类调用某个方法。执行的实际方法可能就是某个子类的覆盖方法。这种不确定性的方法调用，究竟有什么作用呢？

假设我们定义一种收入，需要给它报税，那么先定义一个Income类：

```java
class Income {
    public double income;
    public double getTax() {
        return income * 0.1;
    }
}
```

对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆盖getTax()

```java
class Salary extends Income {
    @override
    public double getTax() {
        if(income <= 5000) {
            return 0;
        }
        return (income - 5000) * 0.2;
    }
}
```

如果你享受国务院特殊津贴，那么按照规定，可以全部免税:

```java
class StateCouncilSpecialAllowance extends {
    @Override
    public double getTax() {
        return 0;
    }
}
```

现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：

```java
public double totalTax(Income... incomes) {
    double total = 0;
    for(Income income : income) {
        total  = total + income.getTax();
    }
}
```



```java
public class Solution {
    public static void main(String args[]) {
      //给一个有普通收入、工资收入和享受国务院特殊精铁的小伙伴算税:
      Income[] incomes = new Income[] {
          new Income(300),
          new Salary(7500),
          new StateCouncilSpecialAllowance(15000)
      };

      System.out.println(totalTax(incomes));
    }

    public static double totalTax(Income... incomes) {
        double total = 0;
        for(Income income : incomes) {
            total = total + income.getTax();
        }
        return total;
    }
}

class Income {
    protected double income;

    public Income(double income) {
        this.income = income;
    }

    public double getTax() {
        return income * 0.1;    //税率10%
    }
}

class Salary extends Income {
    public Salary(double income) {
        super(income);
    }

    @Override
    public double getTax() {
        if(income <= 5000) {
            return 0;
        }
        return (income - 5000) * 0.2;
    }
}

class StateCouncilSpecialAllowance extends Income {
    public StateCouncilSpecialAllowance(double income) {
        super(income);
    }

    @Override
    public double getTax() {
        return 0;
    }
}
```

观察totalTax()方法：利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCOuncilSpecialAllowance的存在，就可以正确计算出总的税收

如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码

课件，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能拓展，却不需要修改基于父类的代码



