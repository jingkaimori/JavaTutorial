什么是反射？

反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息

正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常都会传入对象实例

```java
//Main.java
import com.itranswarp.learnjava.Person;

public class Main {
    String getFullName(Person p) {
        return p.getFirstName() + " " + p.getLastName();
    }
}
```

但是，如果不能获得Person类，只有一个Object实例，比如这样：

```java
String getFullName(Object obj) {
    return ???
}
```

怎么办？有同学会说：强制转换啊

```java
String getFullName(Object obj) {
    Person p = (Person) obj;
    return p.getFirstName() + " " + p.getLastName();
}
```

强制转型的时候，你会发现一个问题，编译上面的代码，仍然需要引用Person类。不然，去掉import语句，你看能不能编译通过



所以，单设是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法



## Class类

除了int等基本类型外，Java的其他类型全部都是class类（包括interface）。例如：

* String
* Object
* Runnable
* Exception

仔细思考，我们可以得出结论：class（包括interface）的本质是数据类型（Type）。无继承关系的数据类型无法赋值

```java
Number n = new Double(123.456);	//OK
String s = new Double(123.456);	//compile error
```

而class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。

每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样：

```java
public final class Class {
    private Class() {}
}
```

以String类为例，当JVM加载String类时，它首先赌气String.class文件到内存，然后，为String类创建一个Class实例并关联起来：

```java
Class cls = new Class(String);
```

这个Class实例时JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序时无法创建Class实例的。

所以，JVM持有的每个Class实例都指向一个数据类型（class或interface）

一个Class实例包含了该class的所有完成信息

由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息

**这种通过Class实例获取class信息的方法称为反射**

如何或者一个class实Class实例？有三个方法：

方法一：直接通过一个class的静态变量class获取：

```java
Class cls = String.class;
```

方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取

```java
String s = "Hello";
Class cls = s.getClass();
```

方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取

```java
Class cls = Class.forName("java.lang.String");
```

因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例：



```java
Class cls1 = String.class;

String s = "Hello";
Class cls2 = s.getClass();

boolean sameClass = cls1 == cls2;	//true
```



注意一下Class实例比较和instanceof发差别：

```java
Integer n = new Integer(123);

boolean b1 = n instanceof Integer;	//true，因为n是Integer类型
boolean b2 = n instanceof Number;	//true，因为n是Number剋行的子类

boolean b3 = n.getClass() == Integer.class;	//true，因为n.getClass()返回Integer.class
boolean b4 = n.getClass() == Number.class;	//false，因为Integer.class != Number.class
```



用instanceof不但匹配指定类型，还匹配指定类型的子类，而且用==判断class实例可以精确地判断数据类型，但不能作子类型比较。

通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例

因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个Object实例时，我们可以通过反射获取到该Object的class信息

```java
void printObjectInfo(Object obj) {
    Class cls = obj.getClass();
}
```



要想从Class实例获取基本信息，参考下面的代码：

```java
public class Main {
    public static void main(String[] args) {
        printClassInfo("".getClass());
        printClassInfo(Runnable.class);
        printClassInfo(java.time.Month.class);
        printClassInfo(String[].class);
        printClassInfo(int.class);
    }
    
    static void printClassInfo(Class cls) {
        System.out.println("Class name: " + cls.getName());
        System.out.println("Simple name: " + cls.getSimpleName());
        if(cls.getPackage() != null) {
            System.out.println("Package name: " + cls.isInterface());
            System.out.println("is enum: " + cls.isEnum());
            System.out.println("is array: " + cls.isArray());
            System.out.println("is primitive: " + cls.isPrimitive());
        }
    } 
}
```

